const Order = require('./order-model.js');
const Cart = require('./cart-model.js');
const Product = require('./product-model.js');
const User = require('./user-model.js'); // Needed for admin checks or populating user info
const catchAsync = require('./catch-async-util.js');
const AppError = require('./app-error-util.js');
// const emailService = require('./email-service.js'); // For sending order confirmation email

// Helper to populate order details
const populateOrderDetails = (query) => {
  return query
    .populate('user', 'name email phone')
    .populate('items.product', 'name images slug'); // Select fields needed for order display
};

// Create a new order
exports.createOrder = catchAsync(async (req, res, next) => {
  const userId = req.user.id;
  const { shippingAddressId, shippingMethodId, paymentMethod, customerNotes } = req.body;

  // 1. Get user's cart
  const cart = await Cart.findOne({ user: userId });
  if (!cart || cart.items.length === 0) {
    return next(new AppError('سبد خرید شما خالی است. نمی‌توان سفارش ثبت کرد.', 400));
  }

  // 2. Validate shipping address (assuming shippingAddressId refers to an address in User.addresses)
  const userWithAddresses = await User.findById(userId).select('+addresses');
  if (!userWithAddresses || !userWithAddresses.addresses) {
      return next(new AppError('کاربر یا آدرس‌های کاربر یافت نشد.', 404));
  }
  const shippingAddress = userWithAddresses.addresses.id(shippingAddressId);
  if (!shippingAddress) {
    return next(new AppError('آدرس ارسال انتخاب شده معتبر نیست.', 400));
  }
  // Create a plain object for embedding, excluding Mongoose internals like _id from subdocument
  const embeddedShippingAddress = {
      receiver: shippingAddress.receiver,
      phone: shippingAddress.phone,
      province: shippingAddress.province,
      city: shippingAddress.city,
      address: shippingAddress.address,
      postalCode: shippingAddress.postalCode,
  };


  // 3. Prepare order items and validate stock
  const orderItems = [];
  let subtotal = 0;

  for (const cartItem of cart.items) {
    const product = await Product.findById(cartItem.product);
    if (!product) {
      return next(new AppError(`محصول با شناسه ${cartItem.product} یافت نشد.`, 404));
    }
    if (product.actualStock < cartItem.quantity) {
      return next(new AppError(`موجودی محصول '${product.name}' (${product.actualStock} عدد) برای تعداد درخواستی (${cartItem.quantity} عدد) کافی نیست.`, 400));
    }

    orderItems.push({
      product: product._id,
      name: product.name, // Denormalized
      image: product.images && product.images.length > 0 ? (product.images.find(img => img.isMain)?.url || product.images[0].url) : undefined, // Denormalized
      price: product.finalPrice, // Price per unit at time of order (after product discount)
      quantity: cartItem.quantity,
    });
    subtotal += product.finalPrice * cartItem.quantity;
  }

  // 4. Determine shipping cost (example, can be more complex)
  // For now, let's assume free shipping or a fixed cost based on shippingMethodId if provided
  let shippingCost = 0;
  if (shippingMethodId === 'express') shippingCost = 50000; // Example cost

  // 5. Handle coupon (already applied to cart.totalPrice via cart.calculateTotalsForDisplay() if used)
  // The cart.totalPrice is subtotal AFTER item discounts.
  // The cart.calculateTotalsForDisplay().couponDiscount is the coupon amount.
  const cartDisplayTotals = cart.calculateTotalsForDisplay();
  const couponDiscount = cartDisplayTotals.couponDiscount || 0;
  const couponCode = cart.coupon ? cart.coupon.code : undefined;

  // 6. Calculate final totalAmount
  const totalAmount = subtotal + shippingCost - couponDiscount;


  // 7. Create the order
  const orderData = {
    user: userId,
    // orderNumber will be generated by pre-save hook in order-model
    items: orderItems,
    shippingAddress: embeddedShippingAddress,
    paymentMethod,
    subtotal,
    shippingCost,
    couponCode,
    couponDiscount,
    totalAmount,
    status: paymentMethod === 'cash_on_delivery' ? 'pending_confirmation' : 'pending_payment', // Initial status
    isPaid: false, // Will be updated upon successful payment
    notes: customerNotes
  };

  const order = await Order.create(orderData);

  // 8. Decrement product stock (important: do this after order is successfully created)
  for (const item of order.items) {
    await Product.findByIdAndUpdate(item.product, {
      $inc: { 'stock.quantity': -item.quantity, 'stock.sold': item.quantity }
    });
    // Note: The Product model's 'sellStock' method could also be used here if preferred,
    // but $inc is generally safe for concurrent updates.
  }

  // 9. Clear the user's cart
  cart.items = [];
  cart.coupon = undefined; // Clear coupon from cart as well
  await cart.save();
  // Or: await Cart.findByIdAndDelete(cart._id); if cart should be removed after order.
  // Keeping the cart document and just clearing items is also valid.

  // 10. (Conceptually) Send order confirmation email
  // try {
  //   await emailService.sendOrderConfirmation(order, req.user);
  // } catch (emailError) {
  //   console.error(`Failed to send order confirmation email for order ${order.orderNumber}:`, emailError);
  //   // Do not fail the request if email fails, but log it.
  // }

  // 11. Populate details for response
  const populatedOrder = await populateOrderDetails(Order.findById(order._id));

  res.status(201).json({
    status: 'success',
    message: 'سفارش شما با موفقیت ثبت شد.',
    data: {
      order: populatedOrder,
    },
  });
});

// Get orders for the currently logged-in user
exports.getMyOrders = catchAsync(async (req, res, next) => {
  const orders = await populateOrderDetails(
    Order.find({ user: req.user.id }).sort('-createdAt')
  );

  res.status(200).json({
    status: 'success',
    results: orders.length,
    data: {
      orders,
    },
  });
});

// Get a specific order by ID (for user or admin)
exports.getOrderById = catchAsync(async (req, res, next) => {
  const query = Order.findById(req.params.id);
  const order = await populateOrderDetails(query);

  if (!order) {
    return next(new AppError('سفارشی با این شناسه یافت نشد.', 404));
  }

  // Check if the user is the owner of the order or an admin
  if (order.user._id.toString() !== req.user.id.toString() && req.user.role !== 'admin') {
    return next(new AppError('شما مجاز به مشاهده این سفارش نیستید.', 403));
  }

  res.status(200).json({
    status: 'success',
    data: {
      order,
    },
  });
});


// --- Admin Functions ---

// Get all orders (Admin)
exports.getAllOrdersAdmin = catchAsync(async (req, res, next) => {
  // Basic pagination (can be enhanced with APIFeatures or model static method like Product.searchProducts)
  const page = parseInt(req.query.page, 10) || 1;
  const limit = parseInt(req.query.limit, 10) || 10;
  const skip = (page - 1) * limit;

  // Basic filtering (can be expanded)
  const filter = {};
  if (req.query.status) filter.status = req.query.status;
  if (req.query.userId) filter.user = req.query.userId;
  // Add date range filters, search by orderNumber, etc.

  const ordersQuery = Order.find(filter)
    .sort('-createdAt')
    .skip(skip)
    .limit(limit);

  const orders = await populateOrderDetails(ordersQuery);
  const totalOrders = await Order.countDocuments(filter);

  res.status(200).json({
    status: 'success',
    results: orders.length,
    totalOrders,
    totalPages: Math.ceil(totalOrders / limit),
    currentPage: page,
    data: {
      orders,
    },
  });
});

// Update order status (Admin)
exports.updateOrderStatusAdmin = catchAsync(async (req, res, next) => {
  const { status, note } = req.body; // New status and optional note

  const order = await Order.findById(req.params.id);
  if (!order) {
    return next(new AppError('سفارشی با این شناسه یافت نشد.', 404));
  }

  // Use the model method to update status and handle stock adjustments if necessary
  await order.updateStatus(status, note || 'وضعیت توسط ادمین تغییر کرد', req.user.id);

  const updatedOrder = await populateOrderDetails(Order.findById(order._id));

  res.status(200).json({
    status: 'success',
    message: 'وضعیت سفارش با موفقیت بروزرسانی شد.',
    data: {
      order: updatedOrder,
    },
  });
});
