const mongoose = require('mongoose'); // Added for ObjectId validation
const Order = require('./order-model.js');
const Cart = require('./cart-model.js');
const Product = require('./product-model.js');
const User = require('./user-model.js'); // Needed for admin checks or populating user info
const catchAsync = require('./catch-async-util.js');
const AppError = require('./app-error-util.js');
// const emailService = require('./email-service.js'); // For sending order confirmation email

// Helper to populate order details
const populateOrderDetails = (query) => {
  return query
    .populate('user', 'name email phone')
    .populate('items.product', 'name images slug'); // Select fields needed for order display
};

// Create a new order
exports.createOrder = catchAsync(async (req, res, next) => {
  const userId = req.user.id;
  const { shippingAddressId, shippingMethodId, paymentMethod, customerNotes } = req.body;

  // --- Input Validation ---
  if (!shippingAddressId || !mongoose.Types.ObjectId.isValid(shippingAddressId)) {
    return next(new AppError('شناسه آدرس ارسال نامعتبر است.', 400));
  }
  const validPaymentMethods = Order.schema.path('paymentMethod').enumValues;
  if (!paymentMethod || !validPaymentMethods.includes(paymentMethod)) {
    return next(new AppError(`روش پرداخت نامعتبر است. مقادیر مجاز: ${validPaymentMethods.join(', ')}`, 400));
  }
  if (customerNotes && typeof customerNotes !== 'string') {
    return next(new AppError('یادداشت مشتری باید به صورت متن باشد.', 400));
  }
  const notesToSave = customerNotes ? customerNotes.trim().slice(0, 500) : undefined; // Example: trim and limit length

  // 1. Get user's cart
  const cart = await Cart.findOne({ user: userId });
  if (!cart || cart.items.length === 0) {
    return next(new AppError('سبد خرید شما خالی است. نمی‌توان سفارش ثبت کرد.', 400));
  }

  // 2. Validate shipping address (assuming shippingAddressId refers to an address in User.addresses)
  const userWithAddresses = await User.findById(userId).select('+addresses');
  if (!userWithAddresses || !userWithAddresses.addresses) {
      return next(new AppError('کاربر یا آدرس‌های کاربر یافت نشد.', 404));
  }
  const shippingAddress = userWithAddresses.addresses.id(shippingAddressId);
  if (!shippingAddress) {
    return next(new AppError('آدرس ارسال انتخاب شده معتبر نیست.', 400));
  }
  // Create a plain object for embedding, excluding Mongoose internals like _id from subdocument
  const embeddedShippingAddress = {
      receiver: shippingAddress.receiver,
      phone: shippingAddress.phone,
      province: shippingAddress.province,
      city: shippingAddress.city,
      address: shippingAddress.address,
      postalCode: shippingAddress.postalCode,
  };


  // 3. Prepare order items and validate stock
  const orderItems = [];
  let subtotal = 0;

  for (const cartItem of cart.items) {
    const product = await Product.findById(cartItem.product);
    if (!product) {
      return next(new AppError(`محصول با شناسه ${cartItem.product} یافت نشد.`, 404));
    }
    if (product.actualStock < cartItem.quantity) {
      return next(new AppError(`موجودی محصول '${product.name}' (${product.actualStock} عدد) برای تعداد درخواستی (${cartItem.quantity} عدد) کافی نیست.`, 400));
    }

    orderItems.push({
      product: product._id,
      name: product.name, // Denormalized
      image: product.images && product.images.length > 0 ? (product.images.find(img => img.isMain)?.url || product.images[0].url) : undefined, // Denormalized
      price: product.finalPrice, // Price per unit at time of order (after product discount)
      quantity: cartItem.quantity,
    });
    subtotal += product.finalPrice * cartItem.quantity;
  }

  // 4. Determine shipping cost (example, can be more complex)
  // For now, let's assume free shipping or a fixed cost based on shippingMethodId if provided
  let shippingCost = 0;
  if (shippingMethodId === 'express') shippingCost = 50000; // Example cost

  // 5. Handle coupon (already applied to cart.totalPrice via cart.calculateTotalsForDisplay() if used)
  // The cart.totalPrice is subtotal AFTER item discounts.
  // The cart.calculateTotalsForDisplay().couponDiscount is the coupon amount.
  const cartDisplayTotals = cart.calculateTotalsForDisplay();
  const couponDiscount = cartDisplayTotals.couponDiscount || 0;
  const couponCode = cart.coupon ? cart.coupon.code : undefined;

  // 6. Calculate final totalAmount
  const totalAmount = subtotal + shippingCost - couponDiscount;


  // 7. Create the order
  const orderData = {
    user: userId,
    // orderNumber will be generated by pre-save hook in order-model
    items: orderItems,
    shippingAddress: embeddedShippingAddress,
    paymentMethod,
    subtotal,
    shippingCost,
    couponCode,
    couponDiscount,
    totalAmount,
    status: paymentMethod === 'cash_on_delivery' ? 'pending_confirmation' : 'pending_payment', // Initial status
    isPaid: false, // Will be updated upon successful payment
    notes: notesToSave
  };

  const order = await Order.create(orderData);

  // 8. Decrement product stock (important: do this after order is successfully created)
  for (const item of order.items) {
    await Product.findByIdAndUpdate(item.product, {
      $inc: { 'stock.quantity': -item.quantity, 'stock.sold': item.quantity }
    });
    // Note: The Product model's 'sellStock' method could also be used here if preferred,
    // but $inc is generally safe for concurrent updates.
  }

  // 9. Clear the user's cart
  cart.items = [];
  cart.coupon = undefined; // Clear coupon from cart as well
  await cart.save();
  // Or: await Cart.findByIdAndDelete(cart._id); if cart should be removed after order.
  // Keeping the cart document and just clearing items is also valid.

  // 10. (Conceptually) Send order confirmation email
  // try {
  //   await emailService.sendOrderConfirmation(order, req.user);
  // } catch (emailError) {
  //   console.error(`Failed to send order confirmation email for order ${order.orderNumber}:`, emailError);
  //   // Do not fail the request if email fails, but log it.
  // }

  // 11. Populate details for response
  const populatedOrder = await populateOrderDetails(Order.findById(order._id));

  res.status(201).json({
    status: 'success',
    message: 'سفارش شما با موفقیت ثبت شد.',
    data: {
      order: populatedOrder,
    },
  });
});

// Get orders for the currently logged-in user
exports.getMyOrders = catchAsync(async (req, res, next) => {
  const orders = await populateOrderDetails(
    Order.find({ user: req.user.id }).sort('-createdAt')
  );

  res.status(200).json({
    status: 'success',
    results: orders.length,
    data: {
      orders,
    },
  });
});

// Get a specific order by ID (for user or admin)
exports.getOrderById = catchAsync(async (req, res, next) => {
  if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
    return next(new AppError('شناسه سفارش نامعتبر است.', 400));
  }
  const query = Order.findById(req.params.id);
  const order = await populateOrderDetails(query);

  if (!order) {
    return next(new AppError('سفارشی با این شناسه یافت نشد.', 404));
  }

  // Check if the user is the owner of the order or an admin
  if (order.user._id.toString() !== req.user.id.toString() && req.user.role !== 'admin') {
    return next(new AppError('شما مجاز به مشاهده این سفارش نیستید.', 403));
  }

  res.status(200).json({
    status: 'success',
    data: {
      order,
    },
  });
});


// --- Admin Functions ---

// Get all orders (Admin)
exports.getAllOrdersAdmin = catchAsync(async (req, res, next) => {
  let { page, limit, status, userId, sort } = req.query;

  page = Math.max(1, parseInt(page, 10) || 1);
  limit = Math.min(100, Math.max(1, parseInt(limit, 10) || 10)); // Default 10, max 100
  const skip = (page - 1) * limit;

  const filter = {};
  if (status) {
    const validStatuses = Order.schema.path('status').enumValues;
    if (!validStatuses.includes(status)) {
      return next(new AppError(`وضعیت نامعتبر. مقادیر مجاز: ${validStatuses.join(', ')}`, 400));
    }
    filter.status = status;
  }
  if (userId) {
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return next(new AppError('شناسه کاربر نامعتبر است.', 400));
    }
    filter.user = userId;
  }

  // Basic sorting, can be expanded
  let sortOption = { createdAt: -1 }; // Default sort: newest first
  if (sort) {
      const [sortField, sortOrder] = sort.split(':');
      if (sortField && (sortOrder === 'asc' || sortOrder === 'desc')) {
          sortOption = { [sortField]: sortOrder === 'asc' ? 1 : -1 };
      } else {
        // Silently ignore invalid sort or return error
      }
  }
  // Add more specific search by orderNumber, customer details etc. if needed.

  const ordersQuery = Order.find(filter)
    .sort(sortOption)
    .skip(skip)
    .limit(limit);

  const orders = await populateOrderDetails(ordersQuery);
  const totalOrders = await Order.countDocuments(filter);

  res.status(200).json({
    status: 'success',
    results: orders.length,
    totalOrders,
    totalPages: Math.ceil(totalOrders / limit),
    currentPage: page,
    data: {
      orders,
    },
  });
});

// Update order status (Admin)
exports.updateOrderStatusAdmin = catchAsync(async (req, res, next) => {
  const { status, note } = req.body;
  const { id: orderId } = req.params;

  if (!mongoose.Types.ObjectId.isValid(orderId)) {
    return next(new AppError('شناسه سفارش نامعتبر است.', 400));
  }

  if (!status) {
    return next(new AppError('وضعیت جدید سفارش الزامی است.', 400));
  }
  const validStatuses = Order.schema.path('status').enumValues;
  if (!validStatuses.includes(status)) {
    return next(new AppError(`وضعیت نامعتبر. مقادیر مجاز: ${validStatuses.join(', ')}`, 400));
  }
  if (note && typeof note !== 'string') {
    return next(new AppError('یادداشت باید به صورت متن باشد.', 400));
  }
  const noteToSave = note ? note.trim().slice(0, 250) : 'وضعیت توسط ادمین تغییر کرد';


  const order = await Order.findById(orderId);
  if (!order) {
    return next(new AppError('سفارشی با این شناسه یافت نشد.', 404));
  }

  // Use the model method to update status and handle stock adjustments if necessary
  // The updateStatus method in model already handles valid transitions.
  await order.updateStatus(status, noteToSave, req.user.id);

  const updatedOrder = await populateOrderDetails(Order.findById(order._id)); // Re-fetch to get populated data

  res.status(200).json({
    status: 'success',
    message: 'وضعیت سفارش با موفقیت بروزرسانی شد.',
    data: {
      order: updatedOrder,
    },
  });
});
